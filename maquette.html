<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <canvas id="canvas" width="300" height="300"></canvas>

    <script type="text/javascript">
    function ArcEnCiel(c) {
      if (typeof c=='undefined'){c={}}
      this.R=c.R||254;
      this.G=c.G||0;
      this.B=c.B||0;
      this.v=c.v||200;
      this.clear={
        R:this.R,
        G:this.G,
        B:this.B,
        v:this.v
      };
    };
    ArcEnCiel.prototype.change = function() {
      if (this.R<255 && this.G<=0 && this.B<=0) {this.R+=this.v}
      else if (this.R>=255 && this.G<255 && this.B<=0) {this.G+=this.v}
      else if (this.R>0 && this.G>=255 && this.B<=0) {this.R-=this.v}
      else if (this.R<=0 && this.G>=255 && this.B<255) {this.B+=this.v}
      else if (this.R<=0 && this.G>0 && this.B>=255) {this.G-=this.v}
      else if (this.R<255 && this.G<=0 && this.B>=255) {this.R+=this.v}
      else {this.B-=this.v}
      if(this.R>255){this.R=255}if(this.R<0){this.R=0}
      if(this.G>255){this.G=255}if(this.G<0){this.G=0}
      if(this.B>255){this.B=255}if(this.B<0){this.B=0}
      this.rgb='rgb('+this.R+','+this.G+','+this.B+')';
      return this.rgb;
    };
    ArcEnCiel.prototype.reset = function() {
      this.R=this.clear.R;
      this.G=this.clear.G;
      this.B=this.clear.B;
      this.v=this.clear.v;
    };
    //port of http://paulbourke.net/geometry/pointlineplane/Helpers.cs
function doLinesIntersect(l1, l2){

  if (l1.p2.x - l2.p1.x == 0 && l1.p2.y - l2.p1.y == 0) return null;
if (l1.p1.x - l2.p2.x == 0 && l1.p1.y - l2.p2.y == 0) return null;

   // Denominator for ua and ub are the same, so store this calculation
   var d =
      (l2.p2.y - l2.p1.y) * (l1.p2.x - l1.p1.x)
      -
      (l2.p2.x - l2.p1.x) * (l1.p2.y - l1.p1.y);

   //n_a and n_b are calculated as seperate values for readability
   var n_a =
      (l2.p2.x - l2.p1.x) * (l1.p1.y - l2.p1.y)
      -
      (l2.p2.y - l2.p1.y) * (l1.p1.x - l2.p1.x);

   var n_b =
      (l1.p2.x - l1.p1.x) * (l1.p1.y - l2.p1.y)
      -
      (l1.p2.y - l1.p1.y) * (l1.p1.x - l2.p1.x);

   // Make sure there is not a division by zero - this also indicates that
   // the lines are parallel.
   // If n_a and n_b were both equal to zero the lines would be on top of each
   // other (coincidental).  This check is not done because it is not
   // necessary for this implementation (the parallel check accounts for this).
   if (d == 0)
      return null;

   // Calculate the intermediate fractional point that the lines potentially intersect.
   var ua = n_a / d;
   var ub = n_b / d;

   // The fractional point will be between 0 and 1 inclusive if the lines
   // intersect.  If the fractional calculation is larger than 1 or smaller
   // than 0 the lines would need to be longer to intersect.
   if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0)
   {
      var intersection = {x:0,y:0};
      intersection.x = l1.p1.x + (ua * (l1.p2.x - l1.p1.x));
      intersection.y = l1.p1.y + (ua * (l1.p2.y - l1.p1.y));
      return intersection;
   }
   return null;
}

      var minx = 200;
      var miny = 200;
      var maxx = 500;
      var maxy = 500;

      var proba_change_direction = 0.2;




      var create_squeleton = function(x,y,lines,squeleton) {
        var local_dir = Math.floor(Math.random()*4);
        var last_dir = -1;
        squeleton.push({x:x,y:y});
        for (var i = 0; i < 1000; i++) {

          x += local_dir==0?-Math.floor(Math.random()*(maxx-minx+1)+minx):local_dir==2?Math.floor(Math.random()*(maxx-minx+1)+minx):0;
          y += local_dir==1?-Math.floor(Math.random()*(maxy-miny+1)+miny):local_dir==3?Math.floor(Math.random()*(maxy-miny+1)+miny):0;

          intersect = null;
          if (squeleton.length > 0) {

            var c = [local_dir,(local_dir+1)%4,(local_dir+3)%4];
            for (var k = 0; k < c.length; k++) {

              var tmpx = x + (c[k]==0?-10000:c[k]==2?10000:0);
              var tmpy = y + (c[k]==1?-10000:c[k]==3?10000:0);
              var l1 = {p1:{x:x,y:y},p2:{x:tmpx,y:tmpy}};

              for (var i = 0; i < lines.length; i++) {
                var l2 = lines[i];

                // check for min dist
                var ray_cast = doLinesIntersect(l1,l2);
                if (ray_cast!=null) {
                  if ((ray_cast.x-x)*(ray_cast.x-x)+(ray_cast.y-y)*(ray_cast.y-y) < minx*minx) return;
                }

              }

            }



            var l1 = {p1:squeleton[squeleton.length-1],p2:{x:x,y:y}};
            for (var i = 0; i < lines.length; i++) {
              var l2 = lines[i];

              // check for collision
              intersect = doLinesIntersect(l1,l2);
              if (intersect!=null) {
                x = intersect.x;
                y = intersect.y;
                break;
              }

            }
          }

          if (last_dir == local_dir) {
            squeleton[squeleton.length-1].x = x;
            squeleton[squeleton.length-1].y = y;
          } else {
            squeleton.push({
              x:x,
              y:y
            });
          }

          if (squeleton.length > 1) {
            lines.push({p1:squeleton[squeleton.length-2],p2:squeleton[squeleton.length-1]});
          }

          if (intersect != null) return;

          last_dir = local_dir;

          var c = [(local_dir+1)%4,(local_dir+3)%4];
          local_dir = Math.random() < proba_change_direction ? c[Math.floor(Math.random()*2)] : local_dir;
        }
      };

      var compute_bound = function(squeleton,bound) {
        if (bound.length==0) {
          bound.push(0);
          bound.push(0);
        }
        for (var i = 0; i < squeleton.length; i++) {
          var x = squeleton[i].x;
          var y = squeleton[i].y;

          if (x > bound[1]) bound[1] = x;
          if (x < bound[0]) bound[0] = x;
          if (y > bound[1]) bound[1] = y;
          if (y < bound[0]) bound[0] = y;
          //if (y > bound[3]) bound[3] = y;
          //if (y < bound[2]) bound[2] = y;

        }
      };



      var wx = 0;
      var wy = 0;
      var scale = 0.1;
      var sx = 350;
      var sy = 350;
      var vx = 0;
      var vy = 0;

      var draw_squeleton = function(bound,squeleton) {
        var n = new ArcEnCiel();
        for (var i = 0; i < squeleton.length; i++) {
          if (i+1 > squeleton.length-1) break;
          ctx.beginPath();
          //var x = squeleton[i].x*340/(bound[1]-bound[0]);
          //var y = squeleton[i].y*340/(bound[1]-bound[0]);
          var x = squeleton[i].x;
          var y = squeleton[i].y;
          ctx.moveTo((x-wx)*scale+sx,(y-wy)*scale+sy);
          //x = squeleton[i+1].x*340/(bound[1]-bound[0]);
          //y = squeleton[i+1].y*340/(bound[1]-bound[0]);
          x = squeleton[i+1].x;
          y = squeleton[i+1].y;
          ctx.lineTo((x-wx)*scale+sx,(y-wy)*scale+sy);
          ctx.lineWidth = 5;
          ctx.strokeStyle = n.change();
          ctx.stroke();
        }
      };


      var lines = [];
      var squeleton = [];
      create_squeleton(0,0,lines,squeleton);

      var bound = [];
      compute_bound(squeleton,bound);
      console.log(bound);



      console.log(squeleton);



      var key = {};
      window.onkeyup = function(e) {
        key[e.keyCode] = false;
        delete key[e.keyCode];
      };
      window.onkeydown = function(e) {
        key[e.keyCode] = true;
      };

      var canvas = document.getElementById('canvas');
      var ctx = canvas.getContext('2d');
      canvas.width = 700;
      canvas.height = 700;
      canvas.style.border = '1px solid #f00';
      function update() {
        window.requestAnimationFrame(update);
        canvas.width = 700;
        canvas.height = 700;
        ctx.font = '20px Verdana';
        ctx.fillStyle = '#000';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('x = '+wx.toFixed(2)+', y = '+wy.toFixed(2)+', scale = '+scale.toFixed(1),0,0);

        ctx.textBaseline = 'bottom';
        ctx.fillText('[A] => zoom out',0,700-40);
        ctx.fillText('[Z] => zoom in',0,700-20);
        ctx.fillText('Press Arrows Key to move',0,700);

        draw_squeleton(bound,squeleton);
        ctx.setTransform(1,0,0,1,0,0);
        if (key[37]) {
          wx -= 5/scale;
        } else if (key[38]) {
          wy -= 5/scale;
        } else if (key[39]) {
          wx += 5/scale;
        } else if (key[40]) {
          wy += 5/scale;
        }
        if (key[90]) {
          scale = Math.min(5, scale * 1.1);
        } else if (key[65]) {
          scale = Math.max(0.1, scale * (1 / 1.1));
        };
      }

      update();

    </script>


  </body>
</html>
